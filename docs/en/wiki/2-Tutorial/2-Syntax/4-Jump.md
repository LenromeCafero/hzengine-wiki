# 跳转

通常，我们为了制作出更复杂的流程，会设置多个 label 标签，而跳转功能，可以让你从当前执行位置跳转到指定的 label 标签处。

与跳转相关的语句有 jump 语句和 call 语句，这两者的功能类似，都是跳转到指定的标签处，但有一些区别。就是 jump 语句不会保存跳转前的位置，而 call 语句会保存跳转前位置到 **调用栈** 中，使用 return 语句，可以返回到 call 之前的位置继续执行。

## jump 语句

语法为，

```renpy
jump <脚本标签名>
```

脚本标签名是 \* 开头的 label 语句声明的。

它会寻找指定的标签的位置，然后告诉 HZengine 下次从目标标签的位置开始执行，不会保存多余的状态。

## call 语句

call 语句也叫调用语句。语法为，

```renpy
call <脚本标签名> 
```

与 jump 语句不同的是，call 语句会告诉 HZengine 记录当前执行的位置。你可以用 return 语句来返回到 call 之前的位置。return 语句很简单，就只有一行：

```renpy
return
```

如果之前使用了 call 语句，return 会使脚本返回到 call 所在的位置执行；如果没有，会直接退出游戏，返回到标题界面。

call 语句是可以嵌套使用的，在此之前，先让我们介绍 **栈（stack）** 是什么。

### 栈

栈是一种数据结构，它具有后进先出(LIFO)的特点。想象一个圆柱形的空瓶子，瓶口和瓶身等粗。你每次刚好可以塞入一个球，最先放进去的球会在瓶子底下，后放入的球会在最顶上。后放进的球可以先拿出来，先放进去的球后拿出来，这就是后进先出(LIFO)。而这个瓶子就是栈，球就是保存在栈中的一项项数据。

调用栈是一种栈，保存在其中的数据是调用信息，在 HZengine 中，这个调用信息就包含了脚本运行的位置。

当刚开始运行一个视觉小说的时候，调用栈是空的。

使用 call 语句时，HZengine 会把当前的执行位置（哪个 hzs 文件的哪一行）放入栈中。如果在 call 语句之后过一会又遇到了一个 call，我们会再次将执行位置入栈，显然 call 语句是可以多次使用的，这叫作嵌套调用。

使用 return 语句时，HZengine 会检查调用栈中是否有之前保存的执行位置。如果有，将它取出，并且跳转回之前的位置；如果没有，也就是栈空了，就结束游戏，回到标题页面。

此外，当执行到一个 hzs 文件的末尾时，HZengine 会隐式执行一个 return 语句。但是，建议你自己加上 return，以增加代码的可读性。

## 一个综合的例子

```renpy
# main.hzs
*start
"今天天气真不错，去哪里逛逛呢？"
"先去图书馆吧"
call 图书馆
"差不多也该吃饭了"
jump 结尾

* 吃饭   
"真香~"   # 注意这句话在这个例子中永远不会出现，因为上面的 jump 结尾直接跳到下面的结尾标签处了

* 结尾
"真是神奇的一天"

# 执行到这里会退出游戏，返回到标题页面，因为文件末尾隐式执行 return 操作
```

```renpy
# library.hzs
* 图书馆
"嗯... 哇！那边有新的阅览室，快去看看"
call 新的阅览室  # 这里嵌套使用了 call 语句
"接下来去哪呢？诶，地上怎么有一本书，好像是刚经过的小孩掉的"
"嗯，我要上去问问"
call 追上小孩还书
"差不多也还该回家了"
return # 返回到之前 call 的位置，也就是 main.hzs 的第5行

* 新的阅览室
"我" "Hello，Eliza！原来你也在这里呀"
"Eliza" "Ciallo~ Asuka，听说有个新阅览室，我就来看了。"
"我" "那我先去其它地方逛逛咯"
"Eliza" "好的，拜拜~"
return  # 返回到之前call的位置，也就是本文件的第3行

* 追上小孩还书
"（一路小跑跟上小男孩）"
"我" "小弟弟，你的书掉了"
"我举起刚才捡的书，不知为何刚才没注意到书名，这竟是一本《逻辑哲学论》"
"我" "呃呃，这应该是你的书吧"
"男孩" "谢谢。这是我刚续借的。不小心掉地上了"
"我将书递给给小男孩，回头往来的方向走去"
"我" "不会吧... 现在的小孩都看这种晦涩难懂的书"
return # 返回到之前call的位置，也就是本文件的第7行。
```

在这个例子中，第一视角的主人公先是去了图书馆，在图书馆中，先去了新的阅览室，离开阅览室后又偶遇掉书的男孩，之后从图书馆离开。可怜的主人公今天没有吃到饭，美好的一天就结束了。如果你能读懂这里的流程，本章的内容也基本没问题了。
